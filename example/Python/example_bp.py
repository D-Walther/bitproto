# Code generated by bitproto. DO NOT EDIT.


"""
Proto drone describes the structure of the drone.
"""


import json
from dataclasses import dataclass, field
from typing import ClassVar, Dict, List, Union
from enum import IntEnum, unique

from bitprotolib import bp


Timestamp = int # 64bit

def bp_processor_Timestamp() -> bp.Processor:
    return bp.AliasProcessor(bp.Int(64))

def bp_default_factory_Timestamp() -> Timestamp:
    return 0


TernaryInt32 = List[int] # 96bit

def bp_processor_TernaryInt32() -> bp.Processor:
    return bp.AliasProcessor(bp.Array(False, 3, bp.Int(32)))

def bp_default_factory_TernaryInt32() -> TernaryInt32:
    return [0 for _ in range(3)]


@unique
class DroneStatus(IntEnum): # 3bit
    DRONE_STATUS_UNKNOWN = 0
    DRONE_STATUS_STANDBY = 1
    DRONE_STATUS_RISING = 2
    DRONE_STATUS_LANDING = 3
    DRONE_STATUS_FLYING = 4


# Aliases for backwards compatibility
DRONE_STATUS_UNKNOWN: DroneStatus = DroneStatus.DRONE_STATUS_UNKNOWN
DRONE_STATUS_STANDBY: DroneStatus = DroneStatus.DRONE_STATUS_STANDBY
DRONE_STATUS_RISING: DroneStatus = DroneStatus.DRONE_STATUS_RISING
DRONE_STATUS_LANDING: DroneStatus = DroneStatus.DRONE_STATUS_LANDING
DRONE_STATUS_FLYING: DroneStatus = DroneStatus.DRONE_STATUS_FLYING


_DRONESTATUS_VALUE_TO_NAME_MAP: Dict[DroneStatus, str] = {
    DroneStatus.DRONE_STATUS_UNKNOWN: "DRONE_STATUS_UNKNOWN",
    DroneStatus.DRONE_STATUS_STANDBY: "DRONE_STATUS_STANDBY",
    DroneStatus.DRONE_STATUS_RISING: "DRONE_STATUS_RISING",
    DroneStatus.DRONE_STATUS_LANDING: "DRONE_STATUS_LANDING",
    DroneStatus.DRONE_STATUS_FLYING: "DRONE_STATUS_FLYING",
}

def bp_processor_DroneStatus() -> bp.Processor:
    return bp.EnumProcessor(bp.Uint(3))


@unique
class PropellerStatus(IntEnum): # 2bit
    PROPELLER_STATUS_UNKNOWN = 0
    PROPELLER_STATUS_IDLE = 1
    PROPELLER_STATUS_ROTATING = 2


# Aliases for backwards compatibility
PROPELLER_STATUS_UNKNOWN: PropellerStatus = PropellerStatus.PROPELLER_STATUS_UNKNOWN
PROPELLER_STATUS_IDLE: PropellerStatus = PropellerStatus.PROPELLER_STATUS_IDLE
PROPELLER_STATUS_ROTATING: PropellerStatus = PropellerStatus.PROPELLER_STATUS_ROTATING


_PROPELLERSTATUS_VALUE_TO_NAME_MAP: Dict[PropellerStatus, str] = {
    PropellerStatus.PROPELLER_STATUS_UNKNOWN: "PROPELLER_STATUS_UNKNOWN",
    PropellerStatus.PROPELLER_STATUS_IDLE: "PROPELLER_STATUS_IDLE",
    PropellerStatus.PROPELLER_STATUS_ROTATING: "PROPELLER_STATUS_ROTATING",
}

def bp_processor_PropellerStatus() -> bp.Processor:
    return bp.EnumProcessor(bp.Uint(2))


@unique
class RotatingDirection(IntEnum): # 2bit
    ROTATING_DIRECTION_UNKNOWN = 0
    ROTATING_DIRECTION_CLOCK_WISE = 1
    ROTATING_DIRECTION_ANTI_CLOCK_WISE = 2


# Aliases for backwards compatibility
ROTATING_DIRECTION_UNKNOWN: RotatingDirection = RotatingDirection.ROTATING_DIRECTION_UNKNOWN
ROTATING_DIRECTION_CLOCK_WISE: RotatingDirection = RotatingDirection.ROTATING_DIRECTION_CLOCK_WISE
ROTATING_DIRECTION_ANTI_CLOCK_WISE: RotatingDirection = RotatingDirection.ROTATING_DIRECTION_ANTI_CLOCK_WISE


_ROTATINGDIRECTION_VALUE_TO_NAME_MAP: Dict[RotatingDirection, str] = {
    RotatingDirection.ROTATING_DIRECTION_UNKNOWN: "ROTATING_DIRECTION_UNKNOWN",
    RotatingDirection.ROTATING_DIRECTION_CLOCK_WISE: "ROTATING_DIRECTION_CLOCK_WISE",
    RotatingDirection.ROTATING_DIRECTION_ANTI_CLOCK_WISE: "ROTATING_DIRECTION_ANTI_CLOCK_WISE",
}

def bp_processor_RotatingDirection() -> bp.Processor:
    return bp.EnumProcessor(bp.Uint(2))


@unique
class PowerStatus(IntEnum): # 2bit
    POWER_STATUS_UNKNOWN = 0
    POWER_STATUS_OFF = 1
    POWER_STATUS_ON = 2


# Aliases for backwards compatibility
POWER_STATUS_UNKNOWN: PowerStatus = PowerStatus.POWER_STATUS_UNKNOWN
POWER_STATUS_OFF: PowerStatus = PowerStatus.POWER_STATUS_OFF
POWER_STATUS_ON: PowerStatus = PowerStatus.POWER_STATUS_ON


_POWERSTATUS_VALUE_TO_NAME_MAP: Dict[PowerStatus, str] = {
    PowerStatus.POWER_STATUS_UNKNOWN: "POWER_STATUS_UNKNOWN",
    PowerStatus.POWER_STATUS_OFF: "POWER_STATUS_OFF",
    PowerStatus.POWER_STATUS_ON: "POWER_STATUS_ON",
}

def bp_processor_PowerStatus() -> bp.Processor:
    return bp.EnumProcessor(bp.Uint(2))


@unique
class LandingGearStatus(IntEnum): # 2bit
    LANDING_GEAR_STATUS_UNKNOWN = 0
    LANDING_GEAR_STATUS_UNFOLDED = 1
    LANDING_GEAR_STATUS_FOLDED = 2


# Aliases for backwards compatibility
LANDING_GEAR_STATUS_UNKNOWN: LandingGearStatus = LandingGearStatus.LANDING_GEAR_STATUS_UNKNOWN
LANDING_GEAR_STATUS_UNFOLDED: LandingGearStatus = LandingGearStatus.LANDING_GEAR_STATUS_UNFOLDED
LANDING_GEAR_STATUS_FOLDED: LandingGearStatus = LandingGearStatus.LANDING_GEAR_STATUS_FOLDED


_LANDINGGEARSTATUS_VALUE_TO_NAME_MAP: Dict[LandingGearStatus, str] = {
    LandingGearStatus.LANDING_GEAR_STATUS_UNKNOWN: "LANDING_GEAR_STATUS_UNKNOWN",
    LandingGearStatus.LANDING_GEAR_STATUS_UNFOLDED: "LANDING_GEAR_STATUS_UNFOLDED",
    LandingGearStatus.LANDING_GEAR_STATUS_FOLDED: "LANDING_GEAR_STATUS_FOLDED",
}

def bp_processor_LandingGearStatus() -> bp.Processor:
    return bp.EnumProcessor(bp.Uint(2))


@dataclass
class Propeller(bp.MessageBase):
    # Number of bytes to serialize class Propeller
    BYTES_LENGTH: ClassVar[int] = 2

    id: int = 0 # 8bit
    status: Union[int, PropellerStatus] = PropellerStatus.PROPELLER_STATUS_UNKNOWN
    # This field is a proxy to hold integer value of enum field 'status'
    _enum_field_proxy__status: int = field(init=False, repr=False) # 2bit
    direction: Union[int, RotatingDirection] = RotatingDirection.ROTATING_DIRECTION_UNKNOWN
    # This field is a proxy to hold integer value of enum field 'direction'
    _enum_field_proxy__direction: int = field(init=False, repr=False) # 2bit

    def __post_init__(self):
        # initialize handling of enum field 'status' as `enum.IntEnum`
        if not isinstance(getattr(Propeller, "status", False), property):
            self._enum_field_proxy__status = self.status
            Propeller.status = property(Propeller._get_status, Propeller._set_status)
        # initialize handling of enum field 'direction' as `enum.IntEnum`
        if not isinstance(getattr(Propeller, "direction", False), property):
            self._enum_field_proxy__direction = self.direction
            Propeller.direction = property(Propeller._get_direction, Propeller._set_direction)

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def _get_status(self) -> PropellerStatus:
        """property getter for enum proxy field"""
        return PropellerStatus(self._enum_field_proxy__status)

    def _set_status(self, val):
        """property setter for enum proxy field"""
        self._enum_field_proxy__status = val
    def _get_direction(self) -> RotatingDirection:
        """property getter for enum proxy field"""
        return RotatingDirection(self._enum_field_proxy__direction)

    def _set_direction(self, val):
        """property setter for enum proxy field"""
        self._enum_field_proxy__direction = val

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Uint(8)),
            bp.MessageFieldProcessor(2, bp_processor_PropellerStatus()),
            bp.MessageFieldProcessor(3, bp_processor_RotatingDirection()),
        ]
        return bp.MessageProcessor(False, 12, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.id |= (int(b) << lshift)
        if di.field_number == 2:
            self.status |= (PropellerStatus(b) << lshift)
        if di.field_number == 3:
            self.direction |= (RotatingDirection(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.id >> rshift) & 255
        if di.field_number == 2:
            return (self.status >> rshift) & 255
        if di.field_number == 3:
            return (self.direction >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class Power(bp.MessageBase):
    # Number of bytes to serialize class Power
    BYTES_LENGTH: ClassVar[int] = 2

    battery: int = 0 # 8bit
    status: Union[int, PowerStatus] = PowerStatus.POWER_STATUS_UNKNOWN
    # This field is a proxy to hold integer value of enum field 'status'
    _enum_field_proxy__status: int = field(init=False, repr=False) # 2bit
    is_charging: bool = False # 1bit

    def __post_init__(self):
        # initialize handling of enum field 'status' as `enum.IntEnum`
        if not isinstance(getattr(Power, "status", False), property):
            self._enum_field_proxy__status = self.status
            Power.status = property(Power._get_status, Power._set_status)

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def _get_status(self) -> PowerStatus:
        """property getter for enum proxy field"""
        return PowerStatus(self._enum_field_proxy__status)

    def _set_status(self, val):
        """property setter for enum proxy field"""
        self._enum_field_proxy__status = val

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Uint(8)),
            bp.MessageFieldProcessor(2, bp_processor_PowerStatus()),
            bp.MessageFieldProcessor(3, bp.Bool()),
        ]
        return bp.MessageProcessor(False, 11, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.battery |= (int(b) << lshift)
        if di.field_number == 2:
            self.status |= (PowerStatus(b) << lshift)
        if di.field_number == 3:
            self.is_charging = bool(b)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.battery >> rshift) & 255
        if di.field_number == 2:
            return (self.status >> rshift) & 255
        if di.field_number == 3:
            return (int(self.is_charging) >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class Network(bp.MessageBase):
    # Number of bytes to serialize class Network
    BYTES_LENGTH: ClassVar[int] = 9

    # Degree of signal, between 1~10.
    signal: int = 0 # 4bit
    # The timestamp of the last time received heartbeat packet.
    heartbeat_at: Timestamp = field(default_factory=bp_default_factory_Timestamp) # 64bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Uint(4)),
            bp.MessageFieldProcessor(2, bp_processor_Timestamp()),
        ]
        return bp.MessageProcessor(False, 68, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.signal |= (int(b) << lshift)
        if di.field_number == 2:
            self.heartbeat_at |= bp.int64((int(b) << lshift))
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.signal >> rshift) & 255
        if di.field_number == 2:
            return (self.heartbeat_at >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class LandingGear(bp.MessageBase):
    # Number of bytes to serialize class LandingGear
    BYTES_LENGTH: ClassVar[int] = 1

    status: Union[int, LandingGearStatus] = LandingGearStatus.LANDING_GEAR_STATUS_UNKNOWN
    # This field is a proxy to hold integer value of enum field 'status'
    _enum_field_proxy__status: int = field(init=False, repr=False) # 2bit

    def __post_init__(self):
        # initialize handling of enum field 'status' as `enum.IntEnum`
        if not isinstance(getattr(LandingGear, "status", False), property):
            self._enum_field_proxy__status = self.status
            LandingGear.status = property(LandingGear._get_status, LandingGear._set_status)

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def _get_status(self) -> LandingGearStatus:
        """property getter for enum proxy field"""
        return LandingGearStatus(self._enum_field_proxy__status)

    def _set_status(self, val):
        """property setter for enum proxy field"""
        self._enum_field_proxy__status = val

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp_processor_LandingGearStatus()),
        ]
        return bp.MessageProcessor(False, 2, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.status |= (LandingGearStatus(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.status >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class Position(bp.MessageBase):
    # Number of bytes to serialize class Position
    BYTES_LENGTH: ClassVar[int] = 12

    latitude: int = 0 # 32bit
    longitude: int = 0 # 32bit
    altitude: int = 0 # 32bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Uint(32)),
            bp.MessageFieldProcessor(2, bp.Uint(32)),
            bp.MessageFieldProcessor(3, bp.Uint(32)),
        ]
        return bp.MessageProcessor(False, 96, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.latitude |= (int(b) << lshift)
        if di.field_number == 2:
            self.longitude |= (int(b) << lshift)
        if di.field_number == 3:
            self.altitude |= (int(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.latitude >> rshift) & 255
        if di.field_number == 2:
            return (self.longitude >> rshift) & 255
        if di.field_number == 3:
            return (self.altitude >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class Pose(bp.MessageBase):
    """
    Pose in flight. https://en.wikipedia.org/wiki/Aircraft_principal_axes
    """
    # Number of bytes to serialize class Pose
    BYTES_LENGTH: ClassVar[int] = 12

    yaw: int = 0 # 32bit
    pitch: int = 0 # 32bit
    roll: int = 0 # 32bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Int(32)),
            bp.MessageFieldProcessor(2, bp.Int(32)),
            bp.MessageFieldProcessor(3, bp.Int(32)),
        ]
        return bp.MessageProcessor(False, 96, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.yaw |= bp.int32((int(b) << lshift))
        if di.field_number == 2:
            self.pitch |= bp.int32((int(b) << lshift))
        if di.field_number == 3:
            self.roll |= bp.int32((int(b) << lshift))
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.yaw >> rshift) & 255
        if di.field_number == 2:
            return (self.pitch >> rshift) & 255
        if di.field_number == 3:
            return (self.roll >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class Flight(bp.MessageBase):
    # Number of bytes to serialize class Flight
    BYTES_LENGTH: ClassVar[int] = 36

    pose: Pose = field(default_factory=Pose) # 96bit
    # Velocity at X, Y, Z axis.
    velocity: TernaryInt32 = field(default_factory=bp_default_factory_TernaryInt32) # 96bit
    # Acceleration at X, Y, Z axis.
    acceleration: TernaryInt32 = field(default_factory=bp_default_factory_TernaryInt32) # 96bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, Pose().bp_processor()),
            bp.MessageFieldProcessor(2, bp_processor_TernaryInt32()),
            bp.MessageFieldProcessor(3, bp_processor_TernaryInt32()),
        ]
        return bp.MessageProcessor(False, 288, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 2:
            self.velocity[di.i(0)] |= bp.int32((int(b) << lshift))
        if di.field_number == 3:
            self.acceleration[di.i(0)] |= bp.int32((int(b) << lshift))
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 2:
            return (self.velocity[di.i(0)] >> rshift) & 255
        if di.field_number == 3:
            return (self.acceleration[di.i(0)] >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        if di.field_number == 1:
            return self.pose
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class PressureSensor(bp.MessageBase):
    # Number of bytes to serialize class PressureSensor
    BYTES_LENGTH: ClassVar[int] = 6

    pressures: List[int] = field(default_factory=lambda: [0 for _ in range(2)]) # 48bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Array(False, 2, bp.Int(24))),
        ]
        return bp.MessageProcessor(False, 48, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.pressures[di.i(0)] |= bp.int32((int(b) << lshift))
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.pressures[di.i(0)] >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        if di.field_number == 1:
            if (self.pressures[di.i(0)] >> 23) & 1:
                self.pressures[di.i(0)] |= -16777216
            return
        return


@dataclass
class Drone(bp.MessageBase):
    # Number of bytes to serialize class Drone
    BYTES_LENGTH: ClassVar[int] = 71

    status: Union[int, DroneStatus] = DroneStatus.DRONE_STATUS_UNKNOWN
    # This field is a proxy to hold integer value of enum field 'status'
    _enum_field_proxy__status: int = field(init=False, repr=False) # 3bit
    position: Position = field(default_factory=Position) # 96bit
    flight: Flight = field(default_factory=Flight) # 288bit
    propellers: List[Propeller] = field(default_factory=lambda: [Propeller() for _ in range(4)]) # 48bit
    power: Power = field(default_factory=Power) # 11bit
    network: Network = field(default_factory=Network) # 68bit
    landing_gear: LandingGear = field(default_factory=LandingGear) # 2bit
    pressure_sensor: PressureSensor = field(default_factory=PressureSensor) # 48bit

    def __post_init__(self):
        # initialize handling of enum field 'status' as `enum.IntEnum`
        if not isinstance(getattr(Drone, "status", False), property):
            self._enum_field_proxy__status = self.status
            Drone.status = property(Drone._get_status, Drone._set_status)

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def _get_status(self) -> DroneStatus:
        """property getter for enum proxy field"""
        return DroneStatus(self._enum_field_proxy__status)

    def _set_status(self, val):
        """property setter for enum proxy field"""
        self._enum_field_proxy__status = val

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp_processor_DroneStatus()),
            bp.MessageFieldProcessor(2, Position().bp_processor()),
            bp.MessageFieldProcessor(3, Flight().bp_processor()),
            bp.MessageFieldProcessor(4, bp.Array(False, 4, Propeller().bp_processor())),
            bp.MessageFieldProcessor(5, Power().bp_processor()),
            bp.MessageFieldProcessor(6, Network().bp_processor()),
            bp.MessageFieldProcessor(7, LandingGear().bp_processor()),
            bp.MessageFieldProcessor(8, PressureSensor().bp_processor()),
        ]
        return bp.MessageProcessor(False, 564, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.status |= (DroneStatus(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.status >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        if di.field_number == 2:
            return self.position
        if di.field_number == 3:
            return self.flight
        if di.field_number == 4:
            return self.propellers[di.i(0)]
        if di.field_number == 5:
            return self.power
        if di.field_number == 6:
            return self.network
        if di.field_number == 7:
            return self.landing_gear
        if di.field_number == 8:
            return self.pressure_sensor
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return